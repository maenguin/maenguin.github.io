

# Java Persistence API (JPA)

## 소개
자바 진영에서 제공하는 ORM 기술이다.
말그대로 객체와 데이터베이스의 릴레이션을 맵핑해주며
개발자가 직접 쿼리를 작성해 데이터를 조작하지 않고 JPA가 대신 쿼리를 생성한다.


## 등장배경

### 객체 지향과 관계형 모델의 대립
자바와 관계형 데이터베이스를 이용해 개발을 한다고 가정해보자(대부분 이 경우 일것이다.)
이 경우 자바의 객체 지향과 관계형 모델의 패러다임 불일치가 발생한다.
그로인해 객체 모델을 관계형 모델로 또 관계형 모델을 객체 모델로 변환하는 번거로운 과정이 필요하고 중복코드를 양산하며 유지보수를 힘들게하는 원인이 되었다.

## 정보

* JPA는 Java aplication과 JDBC사이에서 동작한다.
* JPA는 JDBC의 Wrapper 기술인셈
* JPA는 인터페이스의 모음이다.
* 구현체로는 하이버네이트, EclipseLink, DataNucleus가 있고 JPA 2.1 표준 명세를 토대로 구현되었다.

## 역사

1. EJB - 엔티티 빈(자바 표준)
최초의 Java ORM 기술, 실용성과 성능의 한계로 인해 도태됨
2. 하이버네이트 (오픈 소스)
게빈 킹이 EJB의 한계를 느끼고 직접 ORM framework를 개발
3. JPA (자바 표준)
자바진영에서 하이버네이트를 자바 ORM 표준으로 정립

## 왜 사용해야 하는가?

### SQL 중심적인 개발에서 객체 중심으로 개발

### 생산성
기존의 복잡한 처리 과정을 거치지 않고 단 몇줄의 코드로 CRUD를 수행할 수 있다.
### 유지보수
기존에는 객체의 명세를 변경하면 관련된 SQL을 전부 찾아 변경해야 했지만 JPA가 모두 처리해준다.
### 패러다임 불일치 해결
1. 상속
객체의 상속관계의 경우 테이블을 슈퍼타입과 서브타입 관계로 흉내낼 수 는 있지만 결국 SQL은 테이블별로 나눠서 작성해야한다.
하지만 JPA는 이를 해결해준다.
2. 연관관계
3. 객체 그래프 탐색
4. equal
### 성능

### 데이터 접근 추상화와 벤더 독립성

### 표준

## JPA 구동 방식

1. Persistence 클래스가 설정 정보(META-INF/persistence.xml or application.yml)를 읽고
2. EntityManagerFactory를 생성한다.
3. EntityManagerFactory는 상황에 맞게 EntityManager들을 생성한다.

아래는 스프링없이 순수 java와 jpa만으로 동작하는 코드이며 `Member` 객체를 하나 생성한 뒤 저장하는 예제이다.  
```java
public static void main(String[] args) {

    EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

    EntityManager em = emf.createEntityManager();

    EntityTransaction tx = em.getTransaction();
    tx.begin();

    try {
      Member member = new Member();
      member.setId(1L);
      member.setName("Member1");

      em.persist(member);

      tx.commit();
    } catch (Exception e) {
      tx.rollback();
    } finally {
      em.close();
    }

    emf.close();

  } 
```
코드를 분석해보면, `Persistence.createEntityManagerFactory`에 `persistence-unit name`을 넘겨서 `persistence.xml`에서 설정한 정보를 불러와 `EntityMangerFactory`를 생성하고 있다.  
그 후 생성한 `EntityMangerFactory`를 통해 `EntityManger`를 생성하고 `em.persist(member)`를 통해 member를 저장했다.  

코드를 자세히 보면 `EntityTransaction`을 통해 트랜잭션을 걸고 있는데 이는 **Jpa의 모든 데이터 변경은 무조건 트랜잭션 안에서 동작해야하기 때문이다.**  
그래서 아래와 같은 양식이 꼭 필 수 로 들어가게 된다.
```java
EntityTransaction tx = em.getTransaction();
tx.begin();

//...

tx.commit();
```
> Maven이 아니라 Gradle을 사용하는 경우 엔티티 클래스가 자동으로 인식되지 않는다.  
따로 persistence.xml에 \<class>\</clase>로 엔티티를 추가해주어야한다. 

> EntityManagerFactory는 DB당 하나만 생성해서 애플리케이션 전체에서 공유해야한다.

> EnitityManager는 DB의 커넥션 하나를 물고 있다고 생각하면 된다.  
그렇기 때문에 client에서 요청할때 마다 생성하고 트랜잭션이 끝나면 무조건 close를 해주어야한다.  
쓰레드간에 공유도 하면 안된다.




## JPQL
JPA에서 제공하는 SQL을 추상화한 객체 지향 쿼리 언어  
id를 통한 단건 조회를 제외하고 JPA에서는 `JPQL`을 이용해 조회를 해야한다.
```java
List result = em.createQuery("select m FROM Member as m")
                .setFirstResult(5)
                .setMaxResults(8)
                .getResultList();
```
코드를 보면 익히 알던 SQL 쿼리와 유사하면서도 조금 다르다.  
여기서 Member는 테이블이 아니라 객체를 의미하는데 이는 **JPQL은 엔티티 객체를 대상으로 쿼리**를 만들기 때문이다.  
데이터베이스 테이블을 대상으로 쿼리를 만드는 SQL과 대조적이라 할 수 있다.  

객체를 대상으로 쿼리를 만듬으로서 특정 DB에 종속되지 않는다.  
그래서 DB를 변경한다고 해도 JPQL 변경없이 방언만 변경하면 해당 DB에 맞는 쿼리가 만들어진다.

## 영속성 컨텍스트
엔티티를 영구 저장하는 환경  
JPA는 영속성 컨텍스트라는 환경에서 엔티티를 관리한다.  
엔티티 매니저를 통해 접근  
> J2SE환경에서는 엔티티 매니저와 영속성 컨텍스트가 1:1 관계이지만  
J2EE, 스프링 프레임워크 같은 컨테이너 환경에서는 엔티티 매니저와 영속성 컨텍스트가 N:1의 관계이다.

### 엔티티의 상태
영속성 컨텍스트를 기준으로 다음과 같이 엔티티의 상태를 나눌 수 있다.  

* **비영속** (new/transient)  
  영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
  ```java
  Member member = new Member(1L, "회원1");
  ```
* **영속** (managed)  
  영속성 컨텍스트에 관리되는 상태  
  ```java
  Member member = new Member(1L, "회원1");
  em.persist(member);
  ```
* **준영속** (detached)  
  영속성 컨텍스트에 저장되었다가 분리된 상태
  ```java
  em.detach(member);
  em.clear(); //영속성 컨텍스트 내 엔티티를 모두 준영속으로 전환함.
  em.close();
  ```  
  준영속 상태가 되면 영속성 컨텍스트가 제공하는 기능을 사용하지 못한다.  

* **삭제** (remved)  
  삭제된 상태
  ```java
  em.remove(member);
  ```

### 영속성 컨텍스트의 이점  

* **1차 캐시**  
  영속성 컨텍스트는 `1차 캐시`라는 저장공간을 가지며 이는 말그대로 캐시 기능을 수행한다.  
  특정 엔티티를 찾을때, 그 엔티티가 이미 1차 캐시에 올라와 있는 상황이라면 DB를 조회하지 않고 1차 캐시에 있는 엔티티를 반환하게 된다.  
  em.persist()를 통해 엔티티를 영속화하면 자동으로 1차 캐시에 저장되며 DB에서 가져온 엔티티가 1차 캐시에 없어도 자동으로 저장된다.  
  ```java
  Member member = new Member(1L, "회원1");

  //1차 캐시에 저장됨
  em.persist(member);
  //1차 캐시에서 조회, 1차 캐시에 있으니 DB를 거치지 않음
  em.find(Member.class, 1L);
  //1차 캐시에 없음, DB에서 조회 -> 1차 캐시에 저장 -> 반환
  em.find(Member.class, 2L);
  ```  


* **영속 엔티티의 동일성 보장**  
  기존의 메커니즘에서는 같은 키를 가진 엔티티를 두번 가져오더라도 객체의 관점에서 보았을때 다른 엔티티로 식별된다.  
  하지만 JPA에선 영속성 컨텍스의 1차 캐시 기능 덕에 영속 엔티티의 동일성을 보장한다.  
  ```java
  Member a = em.find(Member.class, "member1");
  Member b = em.find(Member.class, "member1");
  System.out.println(a == b); //true
  ```
  > 1차 캐시로 반복 가능한 읽기(Repeatable Read)등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공  


* **트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)**  
  트랜잭션이 시작된 후 데이터를 저장, 변경, 삭제하는 코드를 호출해도 해당 SQL이 바로 DB에 보내지지 않는다.   
  대신 생성된 SQL이 영속성 컨텍스트의 `쓰기 지연 SQL 저장소`에 차곡차곡 쌓이고 트랜잭션이 커밋되는 순간에 DB로 보내게 된다.  
  ```java
  transaction.begin();

  em.persist(memberA);
  em.remove(memberB);
  memberC.changeName("memberD");
  //여기까지 SQL를 DB에 보내지 않음

  //커밋하는 순산 DB에 쿼리를 보냄
  transaction.commit();
  ```  

* **변경 감지 (dirty checking)**  
  영속성 컨텍스트는 엔티티를 영속할때 1차 캐시에 해당 엔티티의 `스냅샷`을 저장해 놓는다.  
  이 스냅샷과 현재 엔티티를 비교해 변경사항을 감지하고 만약 엔티티가 변경되었다면 SQL을 생성하여 쓰기 지연 SQL 저장소에 저장한다.
  ```java
  transaction.begin();

  Member memberA = em.find(Member.class, "memberA");
  memberA.changeName("memberB");
  //memberA.persist(memberA); 를 안해도 자동으로 변경 감지 되어 SQL이 생성된다!
  transaction.commit();
  ```  

* **지연 로딩 (lazy loading)**
  

### 플러시  
영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는것  
플러시가 호출되면 변경 감지가 실행되어 수정된 엔티티에 대한 SQL이 쓰기 지연 SQL 저장소에 등록되고 등록된 쿼리들이 DB에 전송된다.  
transaction.commit()시 자동으로 호출되며 em.flush()를 통해 직접 호출 할 수 도 있다.  

> JPQL 쿼리를 실행할때도 플러시가 자동 호출된다. (동시성 보장을 위함)  
쿼리 호출시에 플러시를 방지하고 싶다면 em.setFlushMode(FlushModeType.COMMIT)로 설정하면된다.  
  
  
***  



# 엔티티 매핑  
JPA는 ORM으로서 객체와 테이블 매핑을 위해 다양한 에노테이션을 지원한다.  

## 객체와 테이블 매핑  
  
### @Entity  
클래스에 `@Entity`가 붙으면 테이블과 매핑이되며 JPA에서 관리되어진다.  
`@Entity`가 붙은 클래스를 `엔티티`라 한다.  
> **주의**  
JPA내부적으로 리플랙션 기능을 이용하기 위해 **기본 생성자**가 필수로 들어가야 된다.(public or protected)  
final 클래스, enum, interface, inner 클래스에는 사용 불가.  
저장할 필드에 final을 사용하면 안된다.  

#### @Entity 속성
* **name**  
  JPA에서 사용할 엔티티 이름을 지정하는 속성(테이블 이름이 아니다)  
  기본값은 클래스 이름이며 다른 패키지에 같은 클래스 이름이 없는 이상 가급적 기본값을 사용한다.  
    
### @Table  
`@Table`은 엔티티와 매핑할 테이블을 명시적으로 지정할때 사용한다.  
#### 속성
* **name**  
  매핑할 실제 테이블의 이름이 들어가며 기본값은 엔티티 이름  
* **catalog**  
  DB의 catalog를 매핑한다.  
* **schema**  
  DB의 schema를 매핑한다.
* **uniqueConstraints**  
  DDL 생성 시에 유니크 제약 조건을 생성  
  ```java
  @Table(uniqueConstraints = {@UniqueConstraint( name = "NAME_AGE_UNIQUE",
                                                 columnNames = {"NAME", "AGE"} )})
  ```
> name속성의 경우 스프링부트에선 카멜케이스로 적으면 자동으로 `_`로 변환되어 매핑된다.(ex orderHistory -> order_history)  
따로 컨벤션을 지정할 수 도 있다.

> DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA 실행 로직에는 영향을 주지 않는다.  

## 필드와 컬럼 매핑
### @Column
```java
@Column(
    name = "name", //필드와 매핑할 테이블의 컬럼 이름 (기본값 : 객체의 필드 이름)
    insertable = true,    //등록 가능 여부 (기본값 : true)
    updatable = true,    //변경 가능 여부 (기본값 : true)
    nullable = true,     //(DDL용) false로 설정하면 DDL 생성 시에 not null 제약조건이 붙는다. (기본값 : true)
    uinque = false,       //(DDL용) true로 설정하면 DDL 생성 시에 unique 제약 조건이 추가됨 (기본값 : false)
    lenght = 255,         //(DDL용) 문자 길이 제약조건, String 타입에만 사용한다. (기본값 : 255)
    columnDefinition = "varchar(100) default 'EMPTY'", //데이터베이스 컬럼 정보를 직접 줄 수 있다.
    
    precision = 19,     //BigDecimal or BigInterger 타입에서 사용한다. 정밀한 소수를 다루어야 할 때 사용.
    sacale = 2,         //precision은 소수점을 포함한 전체 자릿수를, scale은 소수의 자릿수를 의미한다.
    )
private String username;
```
> @Column으로 유니크 제약조건을 걸게 되면 제약조건 이름을 사용자가 지정할 수 없다.  
그러므로 왠만하면 @Table의 유니크 제약조건을 사용하도록 하자.  

### @Enumerated
자바 enum 타입을 매핑할 때 사용한다.  
* EnumType.ORDINAL : enum **순서**를 데이터베이스에 저장 (기본값)
* EnumType.STRING : enum **이름**을 데이터베이스에 저장
```java
@Enumerated(EnumType.STRING)
private RoleType roleType;
```
> **주의**  
ORDINAL를 사용하게 되면 나중에 추가된 enum 요소 때문에 순서가 꼬일 수 있다.  
무조건 STRING을 사용하자.  

### @Temporal
날짜 타입을 매핑할 때 사용한다.  
자바 8이상 부터는 LocalDate지원하기 때문에 사용하지 않아도 된다.  

### @Lob
데이터베이스 BLOB, CLOB 타입과 매핑한다.  
필드 타입이 문자면 CLOB, 그 이외에는 BLOB으로 자동 매핑된다.  

### @Transient
데이터베이스와 매핑하지 않고 메모리상에서만 임시로 사용할 때 사용한다.  
JPA는 기본적으로 자동 매핑이기 때문에 원하지 않는 매핑 필드가 있으면 사용한다.  


## 기본키 매핑
기본키 매핑을 위해서 @Id와 @GeneratedValue 두개의 에노테이션 존재한다.  
  
### @Id
원하는 필드에 붙이면 PK로 설정된다.  
이후에 `@GerneratedValue`를 사용하지 않으면 엔티티 저장시 직접 id를 할당해야한다.  

### @GeneratedValue
PK 생성 전략을 설정할 수 있다.  

#### AUTO
기본값, 데이터베이스 방언에 따라 밑 3가지 전략중 하나가 자동 선택된다.  

#### IDENTITY
기본 키 생성을 데이터베이스에 위임하는 전략  
주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용 (ex: MySQL의 AUTO_INCREMENT)  
> AUTO_INCEREMENT는 DB에 INSERT SQL을 실행한 이후에야 ID 값을 알 수 있다.  
여기서 JPA는 ID값이 있어야 영속할 수 있기 때문에 IDENTITY 전략은 다른 전략과는 예외적으로  
em.persist() 시점에 즉시 INSERT SQL을 실행하고 ID를 얻어온다.  

#### SEQUENCE
DB 시퀀스 오브젝트를 사용하는 전략  
오라클, PostgreSQL, DB2, H2에서 사용
`@SequenceGenerator`를 통해 생성한 시퀀스를 매핑할 수 있다.  
```java
@Entity
@SequenceGenerator(
        name = "MEMBER_SEQ_GENERATOR" //식별자 생성기 이름 (필수)
        sequenceName = "MEMBER_SEQ",  //매핑할 데이터베이스 시퀀스 이름 (기본값 : hibernate_sequence)
        initialValue = 1,             //DDL 생성 시에만 사용됨, 초기값을 지정한다. (기본값 : 1)
        allocationSize = 1            //시퀀스 한 번 호출에 증가하는 수 (기본값 : 50)
        ) 
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE,
                    generator = "MEMBER_SEQ_GENERATOR")
    private Long id;
}
```
> @SequenceGenerator에서 allocationSize의 기본값은 50이다.  
**DB 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 반드시 1로 설정해야한다.**  

> SEQUENCE 전략도 엔티티 영속을 위해 어쩔 수 없이 DB에 접근해 시퀀스 값을 가져와야한다.  
IDENTITY 전략과는 다르게 em.persist()시 시퀀스 값만 call하고 INSERT SQL을 실행하지 않기 때문에 버퍼링을 할 수 있지만 성능 이슈가 있을 수 있다.   
이때 allocationSize를 설정해서 성능 최적화를 할 수 있다.  
기본 값이 50인데 이렇게 설정하면 시퀀스값 50개를 미리 받아오고 이후부터는 call없이 메모리 상에서 시퀀스를 증가시킨다.  
웹서버가 여러대인경우 서버1은 1\~50 서버2는 51\~100을 미리받는식으로 동작하기 때문에 동시성 문제도 걱정없다.  

#### TABLE
키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략  
모든 데이터베이스에 적용 가능 하지만 성능 때문에 잘 사용하지 않는다.  
`@TableGenerator`로 생성한 테이블을 매핑할 수 있다.  
```ddl
create table MY_SEQUENCES (
    sequence_name varchar(255) not null,
    next_val bigint,
    primary key (sequence_name)
}
```
```java
@Entity
@TableGenerator(
        name = "MEMBER_SEQ_GENERATOR"    //식별자 생성기 이름 (필수)
        table = "MY_SEQUENCE",           //키 생성 테이블명 (기본값 : hibernate_sequences)
        pkColumnValue = "MEMBER_SEQ",    //키로 사용할 값 이름 (기본값 : 엔티티 이름)
        pkColumnValue = "sequence_name", //시퀀스 컬럼명 (기본값 : sequence_name)
        valueColumnNa = "next_val",      //시퀀스 값 컬럼명 (기본값 : next_val)
        initialValue = 0,                //초기값 (기본값 : 0)
        allocationSize = 1               //시퀀스 한 번 호출에 증가하는 수 (기본값 : 50)
        ) 
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE,
                    generator = "MEMBER_SEQ_GENERATOR")
    private Long id;
}
```
```table
MY_SEQUENCE 테이블에
sequence_name next_val
MEMBER_SEQ    1
이런식으로 저장됨
```

